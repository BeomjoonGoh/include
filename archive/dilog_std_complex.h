#ifndef DILOG_STD_COMPLEX_5ZN7UL04
#define DILOG_STD_COMPLEX_5ZN7UL04

std::complex<double> dilog(const std::complex<double>& z) {
  std::complex<double> cy, cz;
  int jsgn, ipi12;
  static const unsigned N = 20;
  // bf[1..N-1] are the even Bernoulli numbers / (2 n + 1)!
  // generated by: Table[BernoulliB[2 n]/(2 n + 1)!, {n, 1, 19}]
  const double bf[N] = {
    -1./4.,
     1./36.,
    -1./36.e2,
     1./21168.e1,
    -1./108864.e2,
     1./52690176.e1,
    -4.0647616451442255268059093862919666745470571274397078e-11,
     8.9216910204564525552179873167527488515142836130490451e-13,
    -1.9939295860721075687236443477937897056306947496538801e-14,
     4.5189800296199181916504765528555932283968190144666184e-16,
    -1.0356517612181247014483411542218656665960912381686505e-17,
     2.3952186210261867457402837430009803816789490019429743e-19,
    -5.5817858743250093362830745056254199055670546676443981e-21,
     1.3091507554183212858123073991865923017498498387833038e-22,
    -3.0874198024267402932422797648664624315955652561327457e-24,
     7.3159756527022034203579056092521485910334010636908750e-26,
    -1.7408456572340007409890551477597025453408414217542713e-27,
     4.1576356446138997196178996207752266734882541595115639e-29,
    -9.9621484882846221031940067024558388498548600173944888e-31,
     2.3940344248961653005211679878937495629342791569329158e-32,
  };

  const double rz = std::real(z);
  const double iz = std::imag(z);
  const double az = std::sqrt(Maths::sqr(rz) + Maths::sqr(iz));

  // special cases
  if (iz == 0.) {
    if (rz <= 1.)
      return std::complex<double>(dilog(rz), 0.);
    if (rz > 1.)
      return std::complex<double>(dilog(rz), -M_PI*std::log(rz));
  } else if (az < std::numeric_limits<double>::epsilon()) {
    return z;
  }

  // transformation to |z|<1, Re(z)<=0.5
  if (rz <= 0.5) {
    if (az > 1.) {
      cy = -0.5 * Maths::sqr(std::log(-z));
      cz = -std::log(1. - 1. / z);
      jsgn = -1;
      ipi12 = -2;
    } else { // (az <= 1.)
      cy = 0;
      cz = -std::log(1. - z);
      jsgn = 1;
      ipi12 = 0;
    }
  } else { // rz > 0.5
    if (az <= std::sqrt(2*rz)) {
      cz = -std::log(z);
      cy = cz * std::log(1. - z);
      jsgn = -1;
      ipi12 = 2;
    } else { // (az > sqrt(2*rz))
      cy = -0.5 * Maths::sqr(std::log(-z));
      cz = -std::log(1. - 1. / z);
      jsgn = -1;
      ipi12 = -2;
    }
  }

  // the dilogarithm
  const std::complex<double> cz2(Maths::sqr(cz));
  std::complex<double> sumC;

  // lowest order terms w/ different powers
  for (unsigned i1 = 2; i1 < N; i1++)
    sumC = cz2 * (sumC + bf[N + 1 - i1]);

  sumC = cz + cz2 * (bf[0] + cz * (bf[1] + sumC));

  const std::complex<double> result = double(jsgn) * sumC + cy + ipi12 * M_PI * M_PI / 12.;

  return result;
}

#endif /* end of include guard: DILOG_STD_COMPLEX_5ZN7UL04 */
